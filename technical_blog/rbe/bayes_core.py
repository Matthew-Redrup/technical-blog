"""Core Bayesian inference functions - updates, sequential processing, and posterior predictive"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/rbe/01_bayes_core.ipynb.

# %% auto 0
__all__ = ['update', 'sequential', 'predictive', 'bayes_factor', 'interpret_bf', 'beta_binomial_update', 'normal_normal_update']

# %% ../../nbs/rbe/01_bayes_core.ipynb 3
import numpy as np
from typing import Optional, Union, List, Callable
from fastcore.test import test_eq, test_close
from fastcore.all import *
from .probability import normalize, sample

# %% ../../nbs/rbe/01_bayes_core.ipynb 5
def update(prior, likelihood, evidence=None):
    "Update `prior` with `likelihood` and optional `evidence`"
    prior, likelihood = np.array(prior), np.array(likelihood)
    if evidence is None: evidence = (prior * likelihood).sum()
    if evidence == 0: raise ValueError("Impossible observation")
    return (prior * likelihood) / evidence

def sequential(priors, likelihoods, evidences=None):
    "Sequential updating of `priors` with `likelihoods`"
    if evidences is None:
        evidences = [None] * len(likelihoods)
    
    posterior = np.array(priors)
    posteriors = [posterior.copy()]
    
    for likelihood, evidence in zip(likelihoods, evidences):
        posterior = update(posterior, likelihood, evidence)
        posteriors.append(posterior.copy())
    
    return np.array(posteriors)

# %% ../../nbs/rbe/01_bayes_core.ipynb 8
def predictive(posterior, likelihood_fn, n_samples=1000, rng=None):
    "Sample from posterior predictive distribution"
    if rng is None: rng = np.random.default_rng()
    
    # Sample parameter values from posterior
    param_samples = sample(posterior, n_samples, rng)
    
    # Generate predictions for each parameter sample
    predictions = []
    for param_idx in param_samples:
        # likelihood_fn should return a distribution over observations
        obs_dist = likelihood_fn(param_idx)
        obs_sample = sample(obs_dist, 1, rng)
        predictions.append(obs_sample)
    
    return np.array(predictions)

# %% ../../nbs/rbe/01_bayes_core.ipynb 11
def bayes_factor(likelihood1, likelihood2, data):
    "Calculate Bayes factor for hypothesis 1 vs 2 given `data`"
    # For single observation
    if np.isscalar(data):
        return likelihood1[data] / likelihood2[data]
    
    # For multiple observations (assuming independence)
    bf = 1.0
    for obs in data:
        bf *= likelihood1[obs] / likelihood2[obs]
    return bf

def interpret_bf(bf):
    "Interpret Bayes factor strength"
    if bf < 1/100:
        return "Decisive evidence against H1"
    elif bf < 1/10:
        return "Strong evidence against H1"
    elif bf < 1/3:
        return "Moderate evidence against H1"
    elif bf < 1:
        return "Weak evidence against H1"
    elif bf < 3:
        return "Weak evidence for H1"
    elif bf < 10:
        return "Moderate evidence for H1"
    elif bf < 100:
        return "Strong evidence for H1"
    else:
        return "Decisive evidence for H1"

# %% ../../nbs/rbe/01_bayes_core.ipynb 14
def beta_binomial_update(alpha, beta, successes, failures):
    "Update Beta prior with binomial data"
    return alpha + successes, beta + failures

def normal_normal_update(prior_mean, prior_var, data_mean, data_var, n_obs):
    "Update Normal prior with Normal likelihood"
    # Precision weighting
    prior_prec = 1 / prior_var
    data_prec = n_obs / data_var
    
    post_prec = prior_prec + data_prec
    post_mean = (prior_prec * prior_mean + data_prec * data_mean) / post_prec
    post_var = 1 / post_prec
    
    return post_mean, post_var

# %% ../../nbs/rbe/01_bayes_core.ipynb 17
__all__ = [
    # Core updates
    'update', 'sequential',
    
    # Posterior predictive
    'predictive',
    
    # Model comparison
    'bayes_factor', 'interpret_bf',
    
    # Conjugate priors
    'beta_binomial_update', 'normal_normal_update'
]
